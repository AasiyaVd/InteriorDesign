<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>La Obsidiané | Upload & Design</title>
    
    <!-- React & DOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Three.js Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;600;700&family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        obsidian: {
                            900: '#050505',
                            800: '#121212',
                            700: '#1e1e1e',
                            600: '#2a2a2a',
                            accent: '#d4af37', 
                            accentHover: '#f1c40f',
                            text: '#e5e5e5',
                            muted: '#a3a3a3'
                        }
                    },
                    fontFamily: {
                        serif: ['"Playfair Display"', 'serif'],
                        sans: ['"Inter"', 'sans-serif'],
                    }
                }
            }
        }
    </script>

    <style>
        body { background-color: #050505; color: #e5e5e5; overflow: hidden; }
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: #121212; }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }
        
        .glass-panel {
            background: rgba(30, 30, 30, 0.9);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
        }

        .canvas-overlay { pointer-events: none; }
        .canvas-overlay > * { pointer-events: auto; }

        .loader {
            border: 3px solid rgba(212, 175, 55, 0.1);
            border-left-color: #d4af37;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { TransformControls } from 'three/addons/controls/TransformControls.js';

        const { useState, useEffect, useRef, useMemo } = React;

        // --- UTILS: PROCEDURAL TEXTURES (Fallback if no image) ---
        const createTexture = (type, colorHex) => {
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = colorHex;
            ctx.fillRect(0, 0, 512, 512);
            if (type === 'wood') {
                ctx.fillStyle = 'rgba(0,0,0,0.1)';
                for(let i=0; i<20; i++) ctx.fillRect(0, i * 25, 512, 20);
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
            return tex;
        };

        // --- COMPONENT: 3D SCENE ---
        const SceneView = ({ 
            uploadedImage, 
            selectedObject, 
            onSelectObject, 
            mode,
            isTopView
        }) => {
            const mountRef = useRef(null);
            const controlsRef = useRef(null);
            const transformControlRef = useRef(null);
            const floorMeshRef = useRef(null);

            // Initialize Scene
            useEffect(() => {
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x111111);
                scene.fog = new THREE.FogExp2(0x111111, 0.015);

                const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
                camera.position.set(0, 15, 0); // Default to Top Down for uploading
                camera.lookAt(0,0,0);

                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                mountRef.current.appendChild(renderer.domElement);

                const controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.maxPolarAngle = Math.PI / 2; 
                controlsRef.current = controls;

                const transformControl = new TransformControls(camera, renderer.domElement);
                transformControl.addEventListener('dragging-changed', (e) => controls.enabled = !e.value);
                scene.add(transformControl);
                transformControlRef.current = transformControl;

                // Lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
                const dirLight = new THREE.DirectionalLight(0xffffff, 1);
                dirLight.position.set(5, 10, 5);
                dirLight.castShadow = true;
                scene.add(dirLight);

                // RAYCASTER
                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();
                const onMouseDown = (e) => {
                    const rect = renderer.domElement.getBoundingClientRect();
                    mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
                    mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects(scene.children, true);
                    if (intersects.length > 0) {
                        let obj = intersects[0].object;
                        while(obj.parent && obj.parent.type !== 'Scene') obj = obj.parent;
                        if (obj !== floorMeshRef.current) { // Don't select the floor
                            transformControl.attach(obj);
                            onSelectObject(obj);
                        } else {
                            transformControl.detach();
                            onSelectObject(null);
                        }
                    } else {
                        transformControl.detach();
                        onSelectObject(null);
                    }
                };
                window.addEventListener('mousedown', onMouseDown);

                const animate = () => {
                    requestAnimationFrame(animate);
                    controls.update();
                    renderer.render(scene, camera);
                };
                animate();
                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                });

                // --- CREATE FLOOR ---
                // Floor Geometry
                const floorGeo = new THREE.PlaneGeometry(20, 20);
                const floorMat = new THREE.MeshStandardMaterial({ 
                    color: 0x333333, 
                    roughness: 0.8,
                    side: THREE.DoubleSide
                });
                const floor = new THREE.Mesh(floorGeo, floorMat);
                floor.rotation.x = -Math.PI / 2;
                floor.receiveShadow = true;
                floor.name = "Floor";
                scene.add(floor);
                floorMeshRef.current = floor;

                // Walls (Hidden by default or placed around edges)
                const wallMat = new THREE.MeshStandardMaterial({ color: 0x888888, transparent: true, opacity: 0.3 });
                const wallGeo = new THREE.BoxGeometry(20, 5, 0.5);
                const w1 = new THREE.Mesh(wallGeo, wallMat); w1.position.set(0, 2.5, -10); scene.add(w1);
                const w2 = new THREE.Mesh(wallGeo, wallMat); w2.position.set(0, 2.5, 10); w2.rotation.y = Math.PI; scene.add(w2);
                const w3 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 5, 20), wallMat); w3.position.set(-10, 2.5, 0); scene.add(w3);
                const w4 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 5, 20), wallMat); w4.position.set(10, 2.5, 0); scene.add(w4);

                window.threeGlobals = { scene, camera, renderer, controls, transformControl, floorMesh: floor };
                return () => {
                    window.removeEventListener('resize', () => {});
                    window.removeEventListener('mousedown', onMouseDown);
                    mountRef.current.removeChild(renderer.domElement);
                };
            }, []);

            // HANDLE UPLOAD TO TEXTURE
            useEffect(() => {
                if (uploadedImage && window.threeGlobals) {
                    const { floorMesh } = window.threeGlobals;
                    const loader = new THREE.TextureLoader();
                    
                    loader.load(uploadedImage, (texture) => {
                        texture.colorSpace = THREE.SRGBColorSpace;
                        texture.wrapS = THREE.ClampToEdgeWrapping;
                        texture.wrapT = THREE.ClampToEdgeWrapping;
                        
                        // Default rotation for floor plans
                        texture.center.set(0.5, 0.5);
                        texture.rotation = -Math.PI / 2;

                        floorMesh.material.map = texture;
                        floorMesh.material.color.set(0xffffff); // Reset base color
                        floorMesh.material.needsUpdate = true;
                    });
                }
            }, [uploadedImage]);

            // Handle View Mode (Top Down vs 3D)
            useEffect(() => {
                if (controlsRef.current) {
                    if (isTopView) {
                        // Move to Top Down
                        const duration = 1000;
                        const startPos = controlsRef.current.object.position.clone();
                        const endPos = new THREE.Vector3(0, 15, 0);
                        const startTime = Date.now();
                        
                        const animateCamera = () => {
                            const now = Date.now();
                            const progress = Math.min((now - startTime) / duration, 1);
                            // Simple ease out
                            const ease = 1 - Math.pow(1 - progress, 3);
                            
                            controlsRef.current.object.position.lerpVectors(startPos, endPos, ease);
                            controlsRef.current.object.lookAt(0,0,0);
                            
                            if (progress < 1) requestAnimationFrame(animateCamera);
                        };
                        animateCamera();
                    } else {
                         // Move to Perspective
                        const duration = 1000;
                        const startPos = controlsRef.current.object.position.clone();
                        const endPos = new THREE.Vector3(8, 8, 8);
                        const startTime = Date.now();
                        
                        const animateCamera = () => {
                            const now = Date.now();
                            const progress = Math.min((now - startTime) / duration, 1);
                            const ease = 1 - Math.pow(1 - progress, 3);
                            
                            controlsRef.current.object.position.lerpVectors(startPos, endPos, ease);
                            
                            if (progress < 1) requestAnimationFrame(animateCamera);
                        };
                        animateCamera();
                    }
                }
            }, [isTopView]);

            // Transform Mode Update
            useEffect(() => {
                if (transformControlRef.current) transformControlRef.current.setMode(mode);
            }, [mode]);

            // Gizmo Update
            useEffect(() => {
                if (transformControlRef.current) {
                    selectedObject ? transformControlRef.current.attach(selectedObject) : transformControlRef.current.detach();
                }
            }, [selectedObject]);

            // Drag Drop Logic
            useEffect(() => {
                const handleDrop = (e) => {
                    e.preventDefault();
                    if (!window.threeGlobals) return;
                    const type = e.dataTransfer.getData("type");
                    if(!type) return;
                    const { scene, camera } = window.threeGlobals;
                    const rect = window.threeGlobals.renderer.domElement.getBoundingClientRect();
                    const mouse = new THREE.Vector2(
                        ((e.clientX - rect.left) / rect.width) * 2 - 1,
                        -((e.clientY - rect.top) / rect.height) * 2 + 1
                    );
                    const raycaster = new THREE.Raycaster();
                    raycaster.setFromCamera(mouse, camera);
                    const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);
                    const target = new THREE.Vector3();
                    raycaster.ray.intersectPlane(plane, target);
                    if (target) window.spawnFurniture(type, target);
                };
                const handleDragOver = (e) => e.preventDefault();
                window.addEventListener('drop', handleDrop);
                window.addEventListener('dragover', handleDragOver);
                return () => {
                    window.removeEventListener('drop', handleDrop);
                    window.removeEventListener('dragover', handleDragOver);
                }
            }, []);

            return <div ref={mountRef} className="absolute top-0 left-0 w-full h-full outline-none" />;
        };

        // --- FURNITURE SPAWNER ---
        window.spawnFurniture = (type, position) => {
            const { scene } = window.threeGlobals;
            const group = new THREE.Group();
            
            const velvet = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.9 });
            const wood = new THREE.MeshStandardMaterial({ color: 0x5c4033, roughness: 0.6 });
            const metal = new THREE.MeshStandardMaterial({ color: 0xc0c0c0, roughness: 0.2, metalness: 0.8 });
            const accent = new THREE.MeshStandardMaterial({ color: 0xd4af37, roughness: 0.3, metalness: 0.6 });

            if (type === 'sofa') {
                const base = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.5, 0.9), velvet);
                base.position.y = 0.25; base.castShadow = true; group.add(base);
                const back = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.7, 0.2), velvet);
                back.position.set(0, 0.6, -0.35); back.castShadow = true; group.add(back);
                const armL = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.5, 0.9), velvet);
                armL.position.set(-1, 0.5, 0); group.add(armL);
                const armR = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.5, 0.9), velvet);
                armR.position.set(1, 0.5, 0); group.add(armR);
            } else if (type === 'table') {
                const top = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 0.05, 32), wood);
                top.position.y = 0.75; top.castShadow = true; group.add(top);
                const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.75), metal);
                leg.position.y = 0.375; group.add(leg);
            } else if (type === 'lamp') {
                const shade = new THREE.Mesh(new THREE.ConeGeometry(0.4, 0.5, 32, 1, true), new THREE.MeshStandardMaterial({ color: 0xeeeeee, side: THREE.DoubleSide }));
                shade.position.y = 1.5; group.add(shade);
                const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 1.5), metal);
                group.add(pole);
                const light = new THREE.PointLight(0xffaa00, 2, 5);
                light.position.y = 1.4; light.castShadow = true; group.add(light);
            }

            group.position.copy(position);
            group.position.y = 0;
            scene.add(group);
        };

        // --- MAIN APP ---
        const App = () => {
            const [view, setView] = useState('landing');
            const [uploadedImage, setUploadedImage] = useState(null);
            const [selectedObject, setSelectedObject] = useState(null);
            const [mode, setMode] = useState('translate');
            const [isTopView, setIsTopView] = useState(true);

            // Handle File Upload
            const handleFileUpload = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        setUploadedImage(reader.result);
                        setView('editor');
                    };
                    reader.readAsDataURL(file);
                }
            };

            // Rotate Floor Texture Helper
            const rotateFloorImage = () => {
                if (window.threeGlobals && window.threeGlobals.floorMesh) {
                    const mat = window.threeGlobals.floorMesh.material;
                    if (mat.map) {
                        mat.map.rotation += Math.PI / 2;
                        mat.map.needsUpdate = true;
                    }
                }
            };

            // Landing Page
            if (view === 'landing') {
                return (
                    <div className="w-full h-screen flex flex-col bg-obsidian-900 relative overflow-hidden">
                        <div className="absolute top-0 left-0 w-full h-full bg-[radial-gradient(circle_at_center,_var(--tw-gradient-stops))] from-obsidian-800 to-obsidian-900 opacity-90 z-0"></div>
                        <div className="relative z-10 flex flex-col items-center justify-center h-full text-center p-6">
                            <h1 className="font-serif text-6xl md:text-8xl text-obsidian-text mb-4 tracking-tight">La Obsidiané</h1>
                            <p className="text-obsidian-muted text-xl font-light mb-12 max-w-2xl">Upload your floor plan to start designing.</p>
                            
                            <div className="glass-panel p-8 rounded-2xl max-w-lg w-full hover:border-obsidian-accent transition-colors duration-500">
                                <button 
                                    onClick={() => document.getElementById('file-upload').click()}
                                    className="w-full border-2 border-dashed border-obsidian-600 rounded-xl p-10 hover:border-obsidian-accent transition-all flex flex-col items-center group">
                                    <i className="fa-solid fa-file-arrow-up text-4xl text-obsidian-accent mb-4 group-hover:scale-110 transition"></i>
                                    <h3 className="text-xl font-medium text-white mb-2">Upload Plan / Sketch</h3>
                                    <p className="text-obsidian-muted text-sm">Supports JPG, PNG</p>
                                </button>
                                <input 
                                    type="file" 
                                    id="file-upload" 
                                    hidden 
                                    accept="image/*"
                                    onChange={handleFileUpload}
                                />
                            </div>
                        </div>
                    </div>
                );
            }

            // Editor View
            return (
                <div className="w-full h-screen flex flex-col bg-obsidian-900">
                    {/* --- HEADER --- */}
                    <header className="h-14 border-b border-white/10 bg-obsidian-800 flex items-center justify-between px-4 z-50">
                        <div className="flex items-center gap-4">
                            <div className="font-serif text-xl tracking-wide text-white">La Obsidiané</div>
                        </div>
                        <div className="flex items-center gap-3">
                             {/* Toggle View Button */}
                            <button 
                                onClick={() => setIsTopView(!isTopView)}
                                className="text-xs bg-white/5 hover:bg-white/10 px-3 py-1.5 rounded text-obsidian-text transition flex items-center gap-2">
                                <i className={`fa-solid ${isTopView ? 'fa-cube' : 'fa-layer-group'}`}></i> 
                                {isTopView ? '3D View' : 'Top View'}
                            </button>
                            <button className="bg-obsidian-accent hover:bg-obsidian-accentHover text-black text-xs font-semibold px-4 py-1.5 rounded transition">
                                Export
                            </button>
                        </div>
                    </header>

                    <div className="flex flex-1 overflow-hidden relative">
                        {/* --- LEFT SIDEBAR --- */}
                        <aside className="w-64 bg-obsidian-800 border-r border-white/10 flex flex-col z-40">
                            <div className="p-4 border-b border-white/5">
                                <h2 className="text-xs font-bold text-obsidian-muted uppercase tracking-wider">Library</h2>
                            </div>
                            <div className="flex-1 overflow-y-auto p-4 space-y-6">
                                <div className="grid grid-cols-2 gap-3">
                                    <div draggable="true" onDragStart={(e) => e.dataTransfer.setData("type", "sofa")} className="bg-obsidian-900 hover:bg-obsidian-700 border border-white/5 rounded p-3 cursor-grab text-center group">
                                        <div className="h-16 flex items-center justify-center text-obsidian-muted group-hover:text-obsidian-accent text-2xl mb-2"><i className="fa-solid fa-couch"></i></div>
                                        <div className="text-xs text-obsidian-muted">Sofa</div>
                                    </div>
                                    <div draggable="true" onDragStart={(e) => e.dataTransfer.setData("type", "table")} className="bg-obsidian-900 hover:bg-obsidian-700 border border-white/5 rounded p-3 cursor-grab text-center group">
                                        <div className="h-16 flex items-center justify-center text-obsidian-muted group-hover:text-obsidian-accent text-2xl mb-2"><i className="fa-solid fa-table"></i></div>
                                        <div className="text-xs text-obsidian-muted">Table</div>
                                    </div>
                                    <div draggable="true" onDragStart={(e) => e.dataTransfer.setData("type", "lamp")} className="bg-obsidian-900 hover:bg-obsidian-700 border border-white/5 rounded p-3 cursor-grab text-center group">
                                        <div className="h-16 flex items-center justify-center text-obsidian-muted group-hover:text-obsidian-accent text-2xl mb-2"><i className="fa-solid fa-lightbulb"></i></div>
                                        <div className="text-xs text-obsidian-muted">Lamp</div>
                                    </div>
                                </div>
                            </div>
                        </aside>

                        {/* --- CENTER CANVAS --- */}
                        <main className="flex-1 relative bg-black">
                            <SceneView 
                                uploadedImage={uploadedImage}
                                selectedObject={selectedObject} 
                                onSelectObject={setSelectedObject}
                                mode={mode}
                                isTopView={isTopView}
                            />
                            
                            {/* --- FLOATING TOOLS (BOTTOM CENTER) --- */}
                            <div className="absolute bottom-6 left-1/2 -translate-x-1/2 glass-panel px-2 py-2 rounded-full flex gap-1 z-50">
                                <button onClick={() => setMode('translate')} className={`w-10 h-10 rounded-full flex items-center justify-center transition ${mode === 'translate' ? 'bg-obsidian-accent text-black' : 'text-obsidian-muted hover:text-white'}`}>
                                    <i className="fa-solid fa-arrows-up-down-left-right"></i>
                                </button>
                                <button onClick={() => setMode('rotate')} className={`w-10 h-10 rounded-full flex items-center justify-center transition ${mode === 'rotate' ? 'bg-obsidian-accent text-black' : 'text-obsidian-muted hover:text-white'}`}>
                                    <i className="fa-solid fa-rotate"></i>
                                </button>
                                <div className="w-[1px] h-6 bg-white/20 my-auto"></div>
                                {/* Rotate Floor Image Button */}
                                <button onClick={rotateFloorImage} className="w-10 h-10 rounded-full flex items-center justify-center text-obsidian-muted hover:text-white transition" title="Rotate Floor Image">
                                    <i className="fa-solid fa-rotate-left"></i>
                                </button>
                            </div>
                        </main>

                        {/* --- RIGHT PROPERTIES PANEL --- */}
                        {selectedObject && (
                            <aside className="w-72 bg-obsidian-800 border-l border-white/10 flex flex-col z-40">
                                <div className="p-4 border-b border-white/5 flex justify-between items-center">
                                    <h2 className="text-xs font-bold text-obsidian-muted uppercase tracking-wider">Properties</h2>
                                    <button onClick={() => setSelectedObject(null)} className="text-obsidian-muted hover:text-white"><i className="fa-solid fa-xmark"></i></button>
                                </div>
                                <div className="p-4 space-y-6">
                                    <div>
                                        <label className="text-xs text-obsidian-muted mb-2 block">Color</label>
                                        <div className="grid grid-cols-5 gap-2">
                                            {['#ffffff', '#222222', '#8B4513', '#d4af37', '#556b2f'].map(c => (
                                                <div key={c} onClick={() => {
                                                    selectedObject.traverse((child) => {
                                                        if(child.isMesh && child.name !== 'glass') child.material.color.set(c);
                                                    })
                                                }} className="w-full aspect-square rounded cursor-pointer border border-white/10" style={{backgroundColor: c}}></div>
                                            ))}
                                        </div>
                                    </div>
                                </div>
                            </aside>
                        )}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>